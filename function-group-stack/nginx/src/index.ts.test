import jwt_decode, { JwtPayload } from "jwt-decode";
let cr = require("crypto");
let cryptoKey: CryptoKey;

interface WaafJwtPayload extends JwtPayload {
  tempTokens?: string[];
}

const stringToBuffer = (str: String) =>
  new Uint8Array([...str].map((c) => c.charCodeAt(0)));

const decodeBase64 = (str: String) =>
  atob(str.replace(/-/g, "+").replace(/_/g, "/"));

function base64urlDecode(str: String) {
  return Buffer.from(base64urlUnescape(str), "base64").toString();
}

function base64urlUnescape(str: String) {
  str += new Array(5 - (str.length % 4)).join("=");
  return str.replace(/\-/g, "+").replace(/_/g, "/");
}

function base64urlEncode(str: String) {
  return base64urlEscape(Buffer.from(str).toString("base64"));
}

function base64urlEscape(str: String) {
  return str.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}

export async function hello(jwtokenRaw: String) {
  if (!cryptoKey) {
    try {
      cryptoKey = await crypto.subtle.importKey(
        "raw",
        stringToBuffer("signing_secret"),
        {
          hash: "SHA-256",
          name: "HMAC",
        },
        true,
        ["sign", "verify"]
      );
    } catch {
      return "FAILED";
    }
  }

  const jwt = jwtokenRaw.replace("Bearer ", "");

  const [header, payload, signature] = jwt.split(".");

  console.log(require("crypto").createHmac);

  console.log(crypto.subtle.verify);

  const valid = await crypto.subtle.verify(
    "HMAC",
    cryptoKey,
    stringToBuffer(decodeBase64(signature)),
    stringToBuffer([header, payload].join("."))
  );

  const token = jwt_decode<WaafJwtPayload>(jwt);
  if (!token.tempTokens) {
    return "NO token";
  }

  if (!valid) {
    return "WTF";
  }
  return token.tempTokens;
}

function sign(headAndPayload: String, key: String) {
  const base64str = require("crypto")
    .createHmac("sha256", key)
    .update(headAndPayload)
    .digest("base64");

  return base64urlEscape(base64str);
}

function verify(headAndPayload: String, key: String, signature: String) {
  return signature === sign(headAndPayload, key);
}

let token =
  "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0ZW1wVG9rZW5zIjpbIjE4ZTc2NzY5OTc3ZWRkOWNjM2I1MDIyNDJjZmMwNWVhYjkxNjc5NjIiXSwiaXNzIjoid2FhZiIsInN1YiI6IjYxNzRhODVjLTdkZmUtNDUyYi04YjJiLTZkYmE4MTA3OTYwYiIsImV4cCI6MTY4MDE3OTg1NSwiaWF0IjoxNjgwMDkzNDU1LCJqdGkiOiI5MDQ3YThkNy1jOGY2LTQzYjctOTYyNC02ZDlhM2U2ODQ1N2MifQ.wXNA3pYjMfHpxM_qJ-uq321lc0Y3S4uOKNQBkB0bUfU";

const jwt = token.replace("Bearer ", "");

const [header, payload, signature] = jwt.split(".");
let valid = verify([header, payload].join("."), "signing_secret", signature);
console.log(valid);

// hello(token).then(console.log);
